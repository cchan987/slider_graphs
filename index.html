<!doctype html>
<p id="tl">path testing</p>
<p id="showing">Showing update:</p>
<p id="direction">Going Forward</p>

<!-- SPEED SLIDER CODE -->
<p>
  <label for="speed" 
         style="display: inline-block; width: 240px; text-align: right">
         Speed = <span id="speed-value">…</span>
  </label>
  <input type="range" min="0" max="1000" value="50" id="speed">
</p>
<!-- END OF SPEED SLIDER CODE -->

<!-- INPUT SLIDER CODE -->
<p>
  <label for="nRadius" 
         style="display: inline-block; width: 240px; text-align: right">
         Input B = <span id="nRadius-value">…</span>
  </label>
  <input type="range" min="-20" max="20" value="5" id="nRadius">
</p>
<!-- END OF INPUT SLIDER CODE -->

<!-- Pause Button -->
<button id="pause_button">Pause</button>

<!-- Reverse Button -->
<button id="reverse_button">Reverse</button>


<html>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="sliders.js"> </script>
<script src="circular_buffer.js"> </script>
<script src="timer_code.js"> </script>
<script src="reverse_code.js"> </script>
<script type="text/javascript">

////////////////////////////Drawing Lines/////////////////////////////////////////////////
function draw_line(chart_data){

	group.selectAll("path")
   		.remove()

   	group.selectAll("path")
   		.data([chart_data])
   		.enter()
   		.append("path")
   		//.attr("width", function(d) {return widthScale(d);})
   		.attr("d",line)
   		.attr("fill", "none")
   		.attr("stroke", "#000")
   		.attr("stroke-width", 1);
}

function update_rand(){
	//perform update on counter for top right 
  //console.log(updates_back)
  if (updates_back == 0){
  	update_count++;
  	document.getElementById('tl').innerHTML= "path testing, update_count: " + update_count;

    //create an object with a random number
  	var rnumber1=Math.floor(Math.random()*input_slider );
  	var temp = {update_number: update_count,y:rnumber1};

    //Push the new data into the chart, push old data to old array and out of old array
  	chart_data.push(temp);
    chart_data_len++;
    if (chart_data_len >= max_data){
      chart_data.shift();
    }
  	//console.log(chart_data);
  	draw_line(chart_data.slice(-101));
    document.getElementById("showing").innerHTML = "Showing update: " + update_count;
  	return temp;
  }
  else{
    updates_back--;
    display_data = chart_data.slice(-101-updates_back,-updates_back);
    draw_line(display_data);
    //console.log(display_data);
    if (typeof display_data[100]=== 'undefined'){
      document.getElementById("showing").innerHTML = "Showing update: " + chart_data_len - max_data;
    }
    else{
      document.getElementById("showing").innerHTML = "Showing update: " + display_data[100].update_number;
    }
  }
}

///////////////////////////////////////////////////////////////////////
var chart_data_len = 101;
var max_data = 1000;

var chart_data = [];
for (var i = 0; i<chart_data_len; i++){
  chart_data.push({time:0,y:5});
}

var update_count = 0;

var widthScale = d3.scale.linear()
					.domain([0,100])
					.range([0,1000]);

var Xaxis = d3.svg.axis()
				.scale(widthScale)
        .ticks(20);

var canvas = d3.select("body").append("svg")
    .attr("width", 5000)
    .attr("height", 500)

canvas.append("g")
	.attr("transform", "translate(100,170)")
	.call(Xaxis);   

var group = canvas.append("g")
			.attr("transform", "translate(100,100)");

var line = d3.svg.line()
	.x(function(d,i) {return i*10;})
	.y(function(d) {return d.y;});		


timer();


</script>
</body>